#include"opencv2/opencv.hpp"
#include <librealsense2/rs.hpp> // Include RealSense Cross Platform API
#include "/home/ahmedshehata/Libraries/librealsense/wrappers/opencv/cv-helpers.hpp"
#include <iostream>

#include <librealsense2/rs.hpp> // Include RealSense Cross Platform API
#include <librealsense2/rsutil.h>
#include "/home/ahmedshehata/Libraries/librealsense/examples/example.hpp"
#include "/home/ahmedshehata/Libraries/librealsense/third-party/imgui/imgui.h"
#include "/home/ahmedshehata/Libraries/librealsense/third-party/imgui/imgui_impl_glfw.h"
#include "opencv2/tracking.hpp"

#include "opencv2/imgcodecs.hpp"
#include "opencv2/imgproc.hpp"
#include "opencv2/videoio.hpp"
#include <opencv2/highgui.hpp>
#include <opencv2/video.hpp>
#include <opencv2/opencv.hpp>
#include <opencv2/tracking.hpp>
#include <opencv2/core/ocl.hpp>

#include "/home/ahmedshehata/Libraries/librealsense/wrappers/opencv/cv-helpers.hpp"

#include <sstream>
#include <iostream>
#include <fstream>
#include <algorithm>
#include <cstring>
#include <chrono>
#include <eigen3/Eigen/Dense>

#include <librealsense2/rs.hpp> // Include RealSense Cross Platform API
#include <librealsense2/rsutil.h>

#define _USE_MATH_DEFINES
#include <math.h>
#include <queue>
#include <unordered_set>
#include <map>
#include <thread>
#include <atomic>
#include <mutex>
#include "ros/ros.h"
#include "track3d/ball_trajectory.h"

using namespace std;
using namespace cv;
using namespace std::chrono;
using pixel = std::pair<int, int>;
//Trackbar inits ---------------------
const int max_value_H = 255;
const int max_value = 255;
const String window_capture_name = "Video Capture";
const String window_detection_name = "Object Detection";
double t_1 = 0, t_2 = 0, delta_t = 0;
int low_H = 0, low_S = 0, low_V = 112;
int high_H = 48, high_S = 208, high_V = 215;
int trackerflag=0;
int counter=0;
int framecount=1;
int point_num=0;
int global_write_flag = 0;
Mat fgMaskMOG2,erosion_dst, dilation_dst, blurred_result; //fg mask fg mask generated by MOG2 method
Ptr<BackgroundSubtractor> pMOG2; //MOG2 Background subtractor
vector <Vec2f> ball_trajectory;
vector <double> time_stamp;
int median_kernel_size = 5, median_max = 20;
int erosion_elem = 2;
int erosion_size = 1;
int dilation_elem = 2;
int dilation_size = 3;
int const max_elem = 2;
int const max_kernel_size = 21;
void Erosion( int, void* );
void Dilation( int, void* );
void median_func(int, void*);
void write_to_file(std::string , std::vector<Vec2f> , std::vector<double>);

//--------------------------------------------------------
//Trackbar defs--------------------------------------------
static void on_low_H_thresh_trackbar(int, void *)
{
    low_H = min(high_H-1, low_H);
    setTrackbarPos("Low H", window_detection_name, low_H);
}
static void on_high_H_thresh_trackbar(int, void *)
{
    high_H = max(high_H, low_H+1);
    setTrackbarPos("High H", window_detection_name, high_H);
}
static void on_low_S_thresh_trackbar(int, void *)
{
    low_S = min(high_S-1, low_S);
    setTrackbarPos("Low S", window_detection_name, low_S);
}
static void on_high_S_thresh_trackbar(int, void *)
{
    high_S = max(high_S, low_S+1);
    setTrackbarPos("High S", window_detection_name, high_S);
}
static void on_low_V_thresh_trackbar(int, void *)
{
    low_V = min(high_V-1, low_V);
    setTrackbarPos("Low V", window_detection_name, low_V);
}
static void on_high_V_thresh_trackbar(int, void *)
{
    high_V = max(high_V, low_V+1);
    setTrackbarPos("High V", window_detection_name, high_V);
}
//---------------------------------------------------------------


Mat image, frame_threshold, equalized, img_hsv,thresholded_rgb;

int i=278;
vector<Vec3f> circles;
// Convert to string
#define SSTR( x ) static_cast< std::ostringstream & >( \
( std::ostringstream() << std::dec << x ) ).str()
int main(int argc, char *argv[])try
{
  //create Background Subtractor objects
   pMOG2 = createBackgroundSubtractorMOG2(); //MOG2 approach
   namedWindow(window_detection_name);
   // Trackbars to set thresholds for HSV values
   createTrackbar("Low H", window_detection_name, &low_H, max_value_H, on_low_H_thresh_trackbar);
   createTrackbar("High H", window_detection_name, &high_H, max_value_H, on_high_H_thresh_trackbar);
   createTrackbar("Low S", window_detection_name, &low_S, max_value, on_low_S_thresh_trackbar);
   createTrackbar("High S", window_detection_name, &high_S, max_value, on_high_S_thresh_trackbar);
   createTrackbar("Low V", window_detection_name, &low_V, max_value, on_low_V_thresh_trackbar);
   createTrackbar("High V", window_detection_name, &high_V, max_value, on_high_V_thresh_trackbar);
   namedWindow( "Erosion Demo", WINDOW_AUTOSIZE );
   namedWindow( "Dilation Demo", WINDOW_AUTOSIZE );
   namedWindow( "median_blurr", WINDOW_AUTOSIZE );
   //moveWindow( "Dilation Demo", src.cols, 0 );
   createTrackbar( "Element:\n 0: Rect \n 1: Cross \n 2: Ellipse", "Erosion Demo",
    &erosion_elem, max_elem,
    Erosion );
   createTrackbar( "Kernel size:\n 2n +1", "Erosion Demo",
    &erosion_size, max_kernel_size,
    Erosion );
   createTrackbar( "Element:\n 0: Rect \n 1: Cross \n 2: Ellipse", "Dilation Demo",
    &dilation_elem, max_elem,
    Dilation );
   createTrackbar( "Kernel size:\n 2n +1", "Dilation Demo",
    &dilation_size, max_kernel_size,
    Dilation );
   createTrackbar( "median_kernel_size", "median_blurr",
    &median_kernel_size, median_max,
    median_func);
//Reading the images and displaying

      while (1)
        {
           if (i>=528)
            {
              i=278;
              counter=0;
              framecount=1;
              //break;
            }

           image = imread("/home/ahmedshehata/Downloads/Ball_traj_recNew/Traj_3alamiya/"+to_string(i)+".jpg", CV_LOAD_IMAGE_COLOR); // Read the file

            if (! image.data )                              // Check for invalid input
              {
                  cout <<  "Could not open or find the image" << std::endl ;
                  return -1;
              }
            i++;
            framecount++;
            double timer = (double)getTickCount();
            t_2=(double)getTickCount();
//            namedWindow( "Display window", WINDOW_AUTOSIZE );// Create a window for display.
//            inRange(image, Scalar(low_H, low_S, low_V), Scalar(high_H, high_S, high_V), frame_threshold);
//            threshold(frame_threshold,frame_threshold,0,1,CV_THRESH_BINARY);
//            cvtColor( frame_threshold, thresholded_rgb, COLOR_GRAY2BGR);
//            multiply(thresholded_rgb,image,thresholded_rgb);
            pMOG2->apply(image, fgMaskMOG2);
            Erosion( 0, 0 );
            median_func(0,0);
            Dilation( 0, 0 );
            imshow("subtracted",fgMaskMOG2);
//            imshow( "Display window", image );
//            imshow("Thresholded_rgb",thresholded_rgb);
            Moments m = moments(dilation_dst,true);
            Point p(m.m10/m.m00, m.m01/m.m00);
            circle(image, p, 5, Scalar(128,0,0), -1);

//            HoughCircles(dilation_dst, circles, HOUGH_GRADIENT, 1,
//                         300,  // change this value to detect circles with different distances to each other
//                         5,5 ,2,8// change the last two parameters
//                         // (min_radius & max_radius) to detect larger circles
//                         );
//            cout<<circles.size()<<endl;
//              if (! circles.empty())
//                {
//                time_stamp.push_back(t_2);//we only send tick count when ball is detected

//                Point ball_center = Point(circles[0].val[0], circles[0].val[1]);
//                ball_trajectory.push_back({circles[0].val[0],circles[0].val[1]});

//      //          circle( image, ball_center, 1, Scalar(0,220,150), 3, LINE_AA);
//                // circle outline
//                float ball_radius = circles[0].val[2];
//      //          circle( image, ball_center, ball_radius, Scalar(0,220,150), 1, LINE_AA);
//                Rect2d bboxer(circles[0].val[0]-5, circles[0].val[1]-5, 15,15);
//                rectangle(image, bboxer, Scalar( 255, 0, 255 ), 2, 1 );
//                circles.clear();
//                }
           float fps = getTickFrequency() / ((double)getTickCount() - timer);
           cout<<fps<<endl;
           // Display FPS on frame
           putText(image, "FPS : " + SSTR(int(fps)), Point(100,50), FONT_HERSHEY_SIMPLEX, 0.75, Scalar(50,170,50), 2);
           imshow( "Display window", image );
//           waitKey(50);
           char key = (char) waitKey(5);
               if (key == 'q' || key == 27)
               {
                   break;
               }
        }
      //Here we write out X_points and Y_points

write_to_file("/home/ahmedshehata/Loggings/ball_trajectory" , ball_trajectory, time_stamp);
return EXIT_SUCCESS;
}
catch (const rs2::error & e)
{
    std::cerr << "RealSense error calling " << e.get_failed_function() << "(" << e.get_failed_args() << "):\n    " << e.what() << std::endl;
    return EXIT_FAILURE;
}
catch (const std::exception & e)
{
    std::cerr << e.what() << std::endl;
    return EXIT_FAILURE;
}

void Erosion( int, void* )
{
  int erosion_type = 0;
  if( erosion_elem == 0 ){ erosion_type = MORPH_RECT; }
  else if( erosion_elem == 1 ){ erosion_type = MORPH_CROSS; }
  else if( erosion_elem == 2) { erosion_type = MORPH_ELLIPSE; }
  Mat element = getStructuringElement( erosion_type,
                       Size( 2*erosion_size + 1, 2*erosion_size+1 ),
                       Point( erosion_size, erosion_size ) );
  erode( fgMaskMOG2, erosion_dst, element );
  imshow( "Erosion Demo", erosion_dst );
}
void Dilation( int, void* )
{
  int dilation_type = 0;
  if( dilation_elem == 0 ){ dilation_type = MORPH_RECT; }
  else if( dilation_elem == 1 ){ dilation_type = MORPH_CROSS; }
  else if( dilation_elem == 2) { dilation_type = MORPH_ELLIPSE; }
  Mat element = getStructuringElement( dilation_type,
                       Size( 2*dilation_size + 1, 2*dilation_size+1 ),
                       Point( dilation_size, dilation_size ) );
  dilate( blurred_result, dilation_dst, element );
  imshow( "Dilation Demo", dilation_dst );
}
void median_func(int, void*)
{
  if(median_kernel_size == 0)
  {
    median_kernel_size = 1;
  }
  if(median_kernel_size%2 == 0)
  {
    median_kernel_size = 2*median_kernel_size - 1;
  }

  medianBlur(erosion_dst,blurred_result,median_kernel_size);
  imshow("median_blurr",blurred_result);
}
void write_to_file(std::string file_name , std::vector<Vec2f> data, std::vector<double> time)
{
    std::ofstream myfile;
    int status;
    if(global_write_flag == 0)
    {
        status = std::remove("/home/ahmedshehata/loggings/ball_trajectory_x.txt");
        status = std::remove("/home/ahmedshehata/loggings/ball_trajectory_y.txt");
        //status = std::remove("/home/ahmedshehata/loggings/ball_trajectory_z.txt");
        status = std::remove("/home/ahmedshehata/loggings/ball_trajectory_t.txt");
        global_write_flag = 1;
    }

    myfile.open(file_name+"_x.txt",std::ios::binary|std::ios::out|std::ios::app);
    if(myfile.is_open())
    {
        for(int i = 0;i<data.size() ;i++)
        {
            myfile<<std::to_string(data[i].val[0])<<std::endl;
        }
        myfile.close();
    }
    myfile.open(file_name+"_y.txt",std::ios::binary|std::ios::out|std::ios::app);
    if(myfile.is_open())
    {
        for(int i = 0;i<data.size();i++)
        {
            myfile<<std::to_string(data[i].val[1])<<std::endl;
        }
        myfile.close();
    }
//    myfile.open(file_name+"_z.txt",std::ios::binary|std::ios::out|std::ios::app);
//    if(myfile.is_open())
//    {
//        for(int i = 0;i<data.size() ;i++)
//        {
//            myfile<<std::to_string(data[i].val[2])<<std::endl;
//        }
//        myfile.close();
//    }

    myfile.open(file_name+"_t.txt",std::ios::binary|std::ios::out|std::ios::app);
    if(myfile.is_open())
    {
        for(int i = 0;i<time.size() ;i++)
        {
            myfile<<std::to_string(time[i])<<std::endl;
        }
        myfile.close();
    }
}





